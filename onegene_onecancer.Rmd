---
title: "Thesis Work"
author: "Lauren Flynn"
date: "2022-11-03"
output: html_document
---

#change from 500 to 5000 families \# make a four column table, one for each level of the families, carrier risk,

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(777)
setwd("/Users/flynnlauren7/Desktop/Internships Summer 2022/Bayes Mendel/PedUtils/R")
files.sources = list.files()
sapply(files.sources, source) #loads in all the PedUtils functions


#load libraries
library(plyr) #need to load plyr before dplyr
library(dplyr)
library(truncnorm)
library(PanelPRO)
library(ggplot2)
```

## Functions to Generate Families

This first section uses the PedUtils package to generate simulated families. The only gene we are including is MLH1 and the only cancer we are including is colorectal cancer.

```{r generate families, warning=FALSE, message=FALSE}
#generate families
families = list()
probandIDS = c()
probandMLH1Status = c()
#outputs = c()
for (i in 1:10) {
  # Cancers
  cancers = "Colorectal"
  # Genes
  genes = "MLH1"
  #family members
  # Paternal aunts, paternal uncles
  nSibsPatern =floor(rtruncnorm(n=2, mean=3, 3))
  # Maternal aunts, maternal uncles
  nSibsMatern = floor(rtruncnorm(n=2, mean=3, 3))
  # Sisters and brothers
  nSibs = floor(rtruncnorm(n=2, mean=3, 3))
  # We make the assumption that the number of sons and daughters for the
  # proband and all siblings, is the same. Nieces and nephews of the proband
  # are not sampled separately.
  nGrandchild = floor(rtruncnorm(n=2, mean=6, 2))
  nChild = floor(rtruncnorm(n=2, mean=3, 2))

  # Simulate family using `PedUtils` code
  fam = sim.runSimFam(nSibsPatern, nSibsMatern, nSibs, nChild,
                      PanelPRODatabase, genes, cancers,
                      includeGeno = TRUE, includeBiomarkers = TRUE)
  famDF = as.data.frame(fam)
  proband = famDF %>% filter(isProband==1)
  probandIDS = c(probandIDS, proband$ID)
  probandMLH1Status = c(probandMLH1Status, proband$MLH1)
  # PanelPRO can be run on the simulated family
  #out = PanelPRO:::PanelPRO11(fam)
  families[[i]] = famDF
  #outputs = c(outputs, out)

}
```


## Remove MLH1 Status from Probands

Here we will create a function to remove the MLH1 status from the probands so that PanelPRO can predict the status. Additionally, there is a function to remove the relative status in order to get information that more accurately resembles the Ambry requistion information.

```{r}


removeProbandStatus <- function(ped){
  proband = ped %>% filter(isProband == 1)
  proband$MLH1 = NA
  relatives = ped %>% filter(isProband == 0)
  fam = rbind(proband, relatives)
  return(fam)
}

removeRelativeStatus <- function(ped){
  proband = ped %>% filter(isProband == 1)
  relatives = ped %>% filter(isProband == 0)
  relatives$MLH1 = NA
  fam = rbind(proband, relatives)
  return(fam)
}

```


Now we can apply the functions on the full families, saving the full families with MLH1 status into a separate variable.
```{r}
mlh1StatusFamilies <- families

for(i in 1:length(families)){
  families[[i]] <- removeProbandStatus(families[[i]])
  families[[i]] <- removeRelativeStatus(families[[i]])
}

```



## First Degree Families

Next we will filter down to the first degree families (proband, parents, siblings).

```{r first degree families function}
firstDegreeFamilyMembers <- function(ped){
  proband <- ped %>% filter(isProband==1)
  firstDegree = proband
  if(!is.null(proband)){
    for(i in  1:nrow(ped)){
      relative=ped[i,]
      #siblings
      if(relative$ID != proband$ID){
        if(!is.null(relative$MotherID) && !is.null(proband$MotherID) && !is.null(relative$FatherID) && !is.null(proband$FatherID) && (relative$MotherID==proband$MotherID) && (relative$FatherID==proband$FatherID)){
          firstDegree <- rbind(firstDegree, relative)
        }
        #parents
        else if(!is.null(proband$MotherID) && !is.null(proband$FatherID) && (relative$ID == proband$MotherID || relative$ID == proband$FatherID)){
          firstDegree <-rbind(firstDegree,relative)
        }
      }
    }
  }
  return(firstDegree)
}
```

## Ambry Information

The Ambry requistion [form](https://www.ambrygen.com/file/material/view/1751/Cancer%20Test%20Requisition%20Form%20(Comprehensive)%20(16403_0).pdf) has limited information about the proband, and very limited information about the proband's family history. Sometimes the only information known about the proband and their family history is from this form or a similar form, so we will simulate the restrictive nature of this data collection for the proband and their relatives. While the ambry form contains a free text box to enter any relatives at all, we will use the function above to restrict to first degree families to ensure that we are able to draw all connections in the pedigree (for example if there is a cousin in the form that we don't know their parents, we won't know where to attach them).

```{r restrict to ambry information functions}
## Function to filter down to Ambry info ##
#### Proband info: sex, age, isDead==no, NA for riskMod and for interAge ###
ambryProbandInfo <- function(ped){
  proband = ped %>% filter(isProband==1)
  #proband$riskmod <- character(0)
  #proband$interAge <- character(0) #should these be character(0)? what does that mean?
  proband$isDead <- 0
  return(proband)
}

### relative info ###
#for simplicity, we will just say that sex can be inferred
#restricting to first degree family
#here genes is just MLH1
ambryRelativeInfo <- function(ped){
  relatives = ped %>% filter(isProband==0)
  #print(relatives)
  relatives$CurAge <- NULL
  relatives$isDead <- NULL
  #relatives$riskMod <- character(0)
  #relatives$interAge <- character(0)
  #View(relatives)
  return(relatives)
}
```

## Filter to Affected Family

Next we want to make a function that will filter to the affected family members in addition to the proband and their parents.

```{r affected family function}
#returns all affected family members and proband (affected or otherwise)
affectedFamilyMembers <- function(ped){
  proband <- ped %>% filter(isProband==1)
  mother <- ped %>% filter(ID == proband$MotherID)
  father <- ped %>% filter(ID == proband$FatherID)
  relatives <- ped %>% filter(isAffAny==1)
  relatives <- relatives %>% filter(isProband==0 && ID != proband$MotherID && ID != proband$FatherID) #to make sure we don't duplicate family members
  affectedFam <- rbind(proband, relatives, mother, father)
  return(affectedFam)
}
```

## Create Families

Using the many functions we have defined above, we can now take our full family pedigrees and generate limited pedigrees.

```{r generating families}
#make first degree families
firstDegree = list()
for(i in 1:length(families)){
  firstDegree[[i]] = firstDegreeFamilyMembers(families[[i]])
}

#restrict to ambry information
ambryFirstDegree = list()
for(i in 1:length(firstDegree)){
  prob = ambryProbandInfo(firstDegree[[i]])
  rels = ambryRelativeInfo(firstDegree[[i]])
  famAm = rbind.fill(prob, rels)
  famAm = famAm %>% affectedFamilyMembers()
  print(nrow(famAm))
  ambryFirstDegree[[i]] = famAm
}
```

#### Family Variable Names and Descriptions

| Variable         | Description                                                                                               |
|------------------------------------|------------------------------------|
| families         | full families, including proband, parents, siblings, aunts, uncles, cousins, etc. generated with PedUtils |
| firstDegree      | first degree families, starting with the full families and restricting to parents, siblings, and proband  |
| ambryFirstDegree | first degree families with information restricted to what can be determined from Ambry requistion form    |

## Descriptions of Families

```{r description of full families function}
describeFamilies <- function(fams){
  affectedFamilies = 0 
  affectedProbands = 0
  famSizes = c()
  mlh1Families = 0
  mlh1Probands = 0 
  #affectedFamiliesList = list()
  #j = 1
  for(i in 1:length(fams)){
    f = fams[[i]]
    sizeOfFamily = nrow(f)
    famSizes = c(famSizes, sizeOfFamily)
    f = f %>% filter(isAffAny==1) %>% filter(isProband==0)
    if(nrow(f)>0){
      affectedFamilies = affectedFamilies + 1
      #affectedFamiliesList[[j]] = f
      #j = j + 1
    }
    mlh1fams = fams[[i]] %>% filter(isProband==0) %>% filter(MLH1==1)
    if(nrow(mlh1fams) > 0){
      mlh1Families = mlh1Families + 1
    }
    pb = fams[[i]] %>% filter(isProband==1)
    if(pb$isAffAny == 1){
      affectedProbands = affectedProbands + 1
    }
    if(!is.na(pb$MLH1)){
      if(pb$MLH1 == 1){
        mlh1Probands = mlh1Probands + 1
      }}
  }
  print(paste0("Number of families: ", length(fams)))
  print(paste0("Number of families with affected individuals: ", affectedFamilies))
  print(paste0("Number of families with affected probands: ", affectedProbands))
  print(paste0("Average family size: ", mean(famSizes)))
  print("Summary of family sizes")
  print(summary(famSizes))
  print(paste0("Number of probands that with MLH1 gene: ", mlh1Probands))
  print(paste0("Number of families (non-proband) with MLH1 gene: ", mlh1Families))
}
```

#### Full Family

Considering MLH1 Status:
```{r description of full families including mlh1 status}
#changing considered families allows us to make this function more reusable
considered_fams = mlh1StatusFamilies
print("Full Families from PedUtils")
describeFamilies(considered_fams)
```



Removed MLH1 Status:
```{r description of full families, cache=TRUE}
#changing considered families allows us to make this function more reusable
considered_fams = families
print("Full Families from PedUtils")
describeFamilies(considered_fams)
```

#### First Degree Families

```{r description of first degree families, cache=TRUE}
considered_fams = firstDegree
print("First Degree Families")
describeFamilies(considered_fams)
```

#### First Degree Families Restricted Information

```{r description of first degree families ambry information, cache=TRUE}
considered_fams = ambryFirstDegree
print("First Degree Families with Restricted Ambry Information")
describeFamilies(considered_fams)
```

## Generating PanelPRO Output

```{r, cache=TRUE}
# #for full families
outputsFull <- list ()
fullCarrierRisk <- list()
considered_fams = families
for(i in 1:length(families)){
  out = PanelPRO::PanelPRO(families[[i]], genes="MLH1", cancers="Colorectal")
  id = as.character(probandIDS[i])
  fullCarrierRisk[[i]] <- out$posterior.prob[[id]]$estimate[2]
  outputsFull[[i]] = out#DF
}

# 
# #for first degree families
outputsFirstDegree <- list ()
firstDegreeCarrierRisk <- list()
considered_fams = firstDegree
for(i in 1:length(families)){
  out = PanelPRO::PanelPRO(firstDegree[[i]], genes="MLH1", cancers="Colorectal")
  id = as.character(probandIDS[i])
  firstDegreeCarrierRisk[[i]] <- out$posterior.prob[[id]]$estimate[2]
  outputsFirstDegree[[i]] = out#DF
}

# 
# 
# #for first degree ambry families
# outputsFirstDegreeAmbry <- list ()
# firstDegreeAmbryCarrierRisk <- list()
# for(i in 1:length(families)){
#   out = PanelPRO::PanelPRO(ambryFirstDegree[[i]], genes="MLH1", cancers="Colorectal")
#   id = as.character(probandIDS[i])
#   firstDegreeAmbryCarrierRisk[[i]] <- out$posterior.prob[[id]]$estimate[2]
#   outputsFirstDegreeAmbry[[i]] = out#DF
# }

```

Above we have put the PanelPRO outputs: 

| Variable | Description | 
| ----- | ---- | 
| fullCarrierRisk | Carrier Risk for MLH1 given the full family pedigree (no MLH1 information) |
| outputsFull | Outputs of PanelPRO for full family pedigree (no MLH1 information) |
| firstDegreeCarrierRisk | Carrier Risk for MLH1 given the first degree family pedigree |
| outputsFirstDegree | Outputs of PanelPro for first degree families (no MLH1 information)|
| firstDegreeAmbryCarrierRisk | Carrier risk for MLH1 given ambry information and restricted pedigree (proband, parents, and affected siblings)|
| outputsFirstDegreeAmbry | PanelPRO outputs for restricted information families|

## Graphs

```{r}
fullRisk <- unlist(fullCarrierRisk)
summary(fullRisk)
fullRisk #here the highest carrier risk corresponds with the actual carrier

firstDegreeRisk <- unlist(firstDegreeCarrierRisk)
summary(firstDegreeRisk)
firstDegreeRisk #here it does not

mlh1FamiliesTotal <- c()
for(i in 1:length(families)){
  if(nrow(mlh1StatusFamilies[[i]] %>% filter(MLH1 ==1)) > 0){
  mlh1FamiliesTotal <- c(mlh1FamiliesTotal, i)} 
}

# ggplot(data= fullRisk) + geom_line
```
